#!/usr/bin/env python3
# The following code was generated by ChatGPT 5
"""
vulnerability_scanner.py

Scan localhost (127.0.0.1) for open TCP ports < 9000, then attempt:
 - HTTP Basic Auth using credentials dict
 - SSH password auth using paramiko (if available)

On successful authentication print exactly:
  http://user:pass@127.0.0.1:8080 <server-output>
  ssh://user:pass@127.0.0.1:2222 <server-output>

No other output is printed unless -v/--verbose is passed (diagnostics go to stderr).
"""

import argparse
import socket
import sys
import time

# Optional imports
try:
    import nmap  # python-nmap
except Exception:
    nmap = None

try:
    import requests
    from requests.auth import HTTPBasicAuth
except Exception as e:
    requests = None

try:
    import paramiko
except Exception:
    paramiko = None

# --- Configuration ---
HOST = "127.0.0.1"
PORT_LIMIT = 9000  # ignore ports >= 9000
CREDENTIALS = {
    "admin": "admin",
    "root": "abc123",
    "skroob": "12345",
}

SOCKET_SCAN_TIMEOUT = 0.25  # seconds for fallback socket connection attempts
NM_SCAN_TIMEOUT = 60  # seconds overall for nmap scan (nmap controls its own timing)
HTTP_TIMEOUT = 3.0
SSH_BANNER_TIMEOUT = 2.0
SSH_AUTH_TIMEOUT = 5.0

# --- Helpers ---


def eprint(*args, **kwargs):
    """Print to stderr (used for verbose messages)."""
    print(*args, file=sys.stderr, **kwargs)


def nm_scan_open_ports(host="127.0.0.1", max_port=PORT_LIMIT):
    """
    Use python-nmap to scan TCP ports from 1..max_port-1 on host.
    Returns a sorted list of open ports (integers).
    If python-nmap or nmap is unavailable, raises RuntimeError.
    """
    if nmap is None:
        raise RuntimeError("python-nmap not available")

    scanner = nmap.PortScanner()
    # Attempt a TCP connect scan of the common range. Keep args minimal for speed.
    # The port range string: 1-(max_port-1)
    port_range = f"1-{max_port-1}"
    try:
        # Note: arguments can be tuned, but keep default safe
        scanner.scan(hosts=host, ports=port_range, arguments="-sT")
    except Exception as exc:
        raise RuntimeError(f"nmap scan error: {exc}") from exc

    open_ports = []
    try:
        host_info = scanner[host]
        tcp_info = host_info.get("tcp", {})
        for p, pinfo in tcp_info.items():
            state = pinfo.get("state", "")
            if state == "open":
                open_ports.append(int(p))
    except Exception:
        # If something unexpected occurs, return empty list
        return []

    return sorted(open_ports)


def socket_scan_open_ports(host="127.0.0.1", max_port=PORT_LIMIT):
    """
    Fallback simple scanner using sockets. Attempts to connect to ports 1..max_port-1.
    Returns a sorted list of open ports.
    """
    open_ports = []
    for port in range(1, max_port):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(SOCKET_SCAN_TIMEOUT)
        try:
            s.connect((host, port))
            open_ports.append(port)
        except Exception:
            pass
        finally:
            try:
                s.close()
            except Exception:
                pass
    return open_ports


def try_http_basic(host, port, username, password, verbose=False):
    """
    Attempt HTTP Basic Auth on host:port with username/password.
    Returns the response text (str) on success (HTTP 2xx or 3xx),
    or None on failure.
    """
    if requests is None:
        if verbose:
            eprint("requests library not available; skipping HTTP attempts.")
        return None

    url = f"http://{host}:{port}/"
    try:
        # Some stub servers might be buggy; be permissive about redirects and codes.
        r = requests.get(url, auth=HTTPBasicAuth(username, password), timeout=HTTP_TIMEOUT)
        # Consider 200-399 as successful; servers may return 200 or 401 for failure.
        if 200 <= r.status_code < 400:
            # return text trimmed of whitespace and newlines
            return r.text.strip()
        else:
            # Non-success status; treat as failure
            return None
    except Exception:
        # swallow errors silently (unless verbose)
        return None


def try_ssh_auth(host, port, username, password, verbose=False):
    """
    Attempt SSH password authentication using paramiko.
    Returns a text string returned by the server on success, or None on failure.
    We make multiple attempts to capture any server-output: banner (pre-auth) and any
    channel output post-auth. The returned string is the best non-empty data we can capture.
    """
    # If paramiko is not installed, skip SSH attempts
    if paramiko is None:
        if verbose:
            eprint("paramiko not available; skipping SSH attempts.")
        return None

    banner_text = ""
    post_auth_text = ""

    # First, attempt to open a plain socket and read a banner (some SSH servers send one).
    sock = None
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(SSH_BANNER_TIMEOUT)
        sock.connect((host, port))
        try:
            # Read banner bytes (non-blocking read)
            sock.settimeout(0.5)
            banner_bytes = b""
            try:
                banner_bytes = sock.recv(4096)
            except Exception:
                banner_bytes = b""
            banner_text = banner_bytes.decode(errors="ignore").strip()
        except Exception:
            banner_text = ""
    except Exception:
        # could not open socket; this port probably isn't speaking TCP or connection refused
        if sock:
            try:
                sock.close()
            except Exception:
                pass
        return None

    # Now try paramiko transport on the socket to authenticate
    try:
        # Wrap existing socket with Paramiko transport
        t = paramiko.Transport(sock)
        t.start_client(timeout=SSH_AUTH_TIMEOUT)
        try:
            # paramiko expects bytes for username/password
            t.auth_password(username, password, timeout=SSH_AUTH_TIMEOUT)
        except paramiko.AuthenticationException:
            # bad credentials
            try:
                t.close()
            except Exception:
                pass
            return None
        except Exception:
            # other auth-related error
            try:
                t.close()
            except Exception:
                pass
            return None

        # If we get here, auth succeeded. Try to open a session and read output.
        try:
            chan = t.open_session(timeout=SSH_AUTH_TIMEOUT)
            try:
                # Attempt to request a pseudo-terminal & invoke a shell so server may send output.
                chan.get_pty()
            except Exception:
                pass
            try:
                chan.invoke_shell()
            except Exception:
                # If invoke_shell fails, try exec_command on the channel
                try:
                    chan.exec_command("echo")
                except Exception:
                    pass

            # Read data (small timeout). The server might send a greeting.
            chan.settimeout(1.0)
            output_chunks = []
            try:
                while True:
                    data = chan.recv(4096)
                    if not data:
                        break
                    output_chunks.append(data)
                    # avoid blocking forever
                    if len(output_chunks) > 10:
                        break
            except Exception:
                # socket timeout or no more data
                pass
            try:
                chan.close()
            except Exception:
                pass

            if output_chunks:
                post_auth_text = b"".join(output_chunks).decode(errors="ignore").strip()
            else:
                post_auth_text = ""
        except Exception:
            post_auth_text = ""
        finally:
            try:
                t.close()
            except Exception:
                pass
    except Exception:
        # paramiko.Transport construction/start_client failed - make sure socket is closed
        try:
            sock.close()
        except Exception:
            pass
        return None

    # Choose the best output: prefer post-auth output; else banner
    result = post_auth_text.strip() if post_auth_text.strip() else banner_text.strip()
    return result if result != "" else ""  # return empty string rather than None if authenticated but no output


def attempt_credentials_on_port(host, port, credentials, verbose=False):
    """
    For a given host:port attempt HTTP Basic and SSH auth with each credential.
    If a successful auth is found for a protocol, print exactly one line as spec requires.
    Returns nothing (prints only on success).
    """
    # HTTP attempts
    for user, pwd in credentials.items():
        try:
            http_output = try_http_basic(host, port, user, pwd, verbose=verbose)
            if http_output is not None:
                # Print exactly one line:
                # http://user:pass@host:port <server-output>
                # server-output may be empty; still print the trailing space and then output
                print(f"http://{user}:{pwd}@{host}:{port} {http_output}")
                # Do not attempt further credentials for HTTP on this port (per spec we print matching)
                break
        except Exception:
            # swallow any unexpected exception
            continue

    # SSH attempts
    for user, pwd in credentials.items():
        try:
            ssh_output = try_ssh_auth(host, port, user, pwd, verbose=verbose)
            # Note: try_ssh_auth returns None on auth failure and either empty string "" or some text on success.
            if ssh_output is not None:
                # If ssh_output is None -> auth failed. If not None -> auth succeeded (might be "")
                # Print line
                print(f"ssh://{user}:{pwd}@{host}:{port} {ssh_output}")
                break
        except Exception:
            # swallow exceptions
            continue


def main():
    parser = argparse.ArgumentParser(description="Local vulnerability scanner (HTTP basic + SSH password) for localhost")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose diagnostics to stderr")
    args = parser.parse_args()
    verbose = args.verbose

    # Step 1: discover open ports < PORT_LIMIT
    open_ports = []
    if nmap is not None:
        try:
            if verbose:
                eprint("Using python-nmap to discover open ports...")
            open_ports = nm_scan_open_ports(HOST, PORT_LIMIT)
        except Exception as exc:
            if verbose:
                eprint(f"nmap scan failed (falling back to socket scan): {exc}")
            open_ports = socket_scan_open_ports(HOST, PORT_LIMIT)
    else:
        if verbose:
            eprint("python-nmap not available; using socket-based scan.")
        open_ports = socket_scan_open_ports(HOST, PORT_LIMIT)

    if verbose:
        eprint(f"Open ports under {PORT_LIMIT}: {open_ports}")

    # For each open port try credentials
    for port in open_ports:
        # per spec, ignore ports numbered 9000 and higher
        if port >= PORT_LIMIT:
            continue
        if verbose:
            eprint(f"Probing port {port}...")
        try:
            attempt_credentials_on_port(HOST, port, CREDENTIALS, verbose=verbose)
        except Exception:
            # swallow any exceptions, continue scanning
            continue


if __name__ == "__main__":
    main()
