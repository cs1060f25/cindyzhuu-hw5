#!/usr/bin/env python3
"""
Authored by ChatGPT 5
vulnerability_scanner.py

Scan localhost (127.0.0.1) for open TCP ports < 9000, then attempt:
 - HTTP Basic Auth using credentials dict
 - SSH password auth using paramiko (if available)

On successful authentication print exactly:
  http://user:pass@127.0.0.1:8080 <server-output>
  ssh://user:pass@127.0.0.1:2222 <server-output>

No other stdout output. Use -v/--verbose to send diagnostics to stderr only.
"""

from __future__ import annotations
import argparse
import socket
import sys
import re
import logging
logging.getLogger("paramiko").setLevel(logging.CRITICAL)
logging.getLogger("paramiko.transport").setLevel(logging.CRITICAL)


# Optional modules
try:
    import nmap  # python-nmap
except Exception:
    nmap = None

try:
    import requests
    from requests.auth import HTTPBasicAuth
except Exception:
    requests = None

try:
    import paramiko
except Exception:
    paramiko = None

# Silence paramiko internal logging/noisy messages
logging.getLogger("paramiko").setLevel(logging.CRITICAL)
logging.getLogger("paramiko.transport").setLevel(logging.CRITICAL)

# -------------- Configuration --------------
HOST = "127.0.0.1"
PORT_LIMIT = 9000  # ignore ports >= 9000
CREDENTIALS = {
    "admin": "admin",
    "root": "abc123",
    "skroob": "12345",
}

SOCKET_SCAN_TIMEOUT = 0.2  # seconds per port on fallback scan
HTTP_TIMEOUT = 3.0
SSH_AUTH_TIMEOUT = 5.0
SSH_CHANNEL_READ_TIMEOUT = 1.0
MAX_OUTPUT_CHARS = 2000  # truncate long outputs

# Regex to collapse whitespace
_whitespace_re = re.compile(r"\s+")


# -------------- Utilities --------------
def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def sanitize_output(s: str | None, max_len: int = MAX_OUTPUT_CHARS) -> str:
    """Collapse whitespace to single spaces, trim, and truncate to a single-line string."""
    if s is None:
        return ""
    s2 = _whitespace_re.sub(" ", s.strip())
    if len(s2) > max_len:
        s2 = s2[:max_len]
    return s2


# -------------- Port discovery --------------
def nmap_scan_open_ports(host: str = HOST, max_port: int = PORT_LIMIT, verbose: bool = False) -> list[int]:
    """
    Use python-nmap to scan TCP ports 1..max_port-1.
    Requires the nmap binary to be available; python-nmap will raise if it isn't.
    """
    if nmap is None:
        raise RuntimeError("python-nmap not installed")
    scanner = nmap.PortScanner()
    port_range = f"1-{max_port - 1}"
    try:
        # -sT TCP connect scan; -Pn treat host as up
        scanner.scan(hosts=host, ports=port_range, arguments="-sT -Pn")
    except Exception as exc:
        raise RuntimeError(f"nmap scan error: {exc}") from exc

    open_ports: list[int] = []
    try:
        host_info = scanner[host]
        tcp_info = host_info.get("tcp", {}) or {}
        for p_str, info in tcp_info.items():
            if str(info.get("state", "")).lower() == "open":
                open_ports.append(int(p_str))
    except Exception:
        # Unexpected structure; return empty
        return []
    return sorted(open_ports)


def socket_scan_open_ports(host: str = HOST, max_port: int = PORT_LIMIT) -> list[int]:
    """Fallback: simple socket connect scan for ports 1..max_port-1."""
    open_ports = []
    for port in range(1, max_port):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(SOCKET_SCAN_TIMEOUT)
        try:
            if s.connect_ex((host, port)) == 0:
                open_ports.append(port)
        except Exception:
            # ignore
            pass
        finally:
            try:
                s.close()
            except Exception:
                pass
    return open_ports


# -------------- HTTP probing --------------
def try_http_basic(host: str, port: int, username: str, password: str, verbose: bool = False) -> str | None:
    """
    Attempt HTTP Basic Auth to http://host:port/.
    Return response body on true success (HTTP 2xx + text/plain + non-empty body), else None.
    """
    if requests is None:
        return None

    url = f"http://{host}:{port}/"
    try:
        r = requests.get(url, auth=HTTPBasicAuth(username, password),
                         timeout=HTTP_TIMEOUT, allow_redirects=False)
    except Exception:
        return None

    # Strict success criteria to avoid false positives on random services/pages.
    if not (200 <= r.status_code < 300):
        return None

    ctype = (r.headers.get("Content-Type") or "").lower()
    if "text/plain" not in ctype:
        # Avoid printing HTML error pages or JSON, etc.
        return None

    # Body must be non-empty and not look like HTML
    body = ""
    try:
        body = r.text or ""
    except Exception:
        try:
            body = r.content.decode(errors="ignore")
        except Exception:
            body = ""

    body_stripped = body.strip()
    if not body_stripped:
        return None
    if body_stripped[:32].lower().startswith("<!doctype") or "<html" in body_stripped[:128].lower():
        return None

    return body



# -------------- SSH probing --------------
def try_ssh_password(host: str, port: int, username: str, password: str, verbose: bool = False) -> str | None:
    """
    Attempt SSH password authentication via paramiko.
    Return captured post-auth channel output (non-empty) on success; otherwise None.
    NOTE: We intentionally do NOT fall back to printing protocol/banner text.
    """
    if paramiko is None:
        if verbose:
            eprint("[ssh] paramiko not available; skipping SSH attempts.")
        return None

    sock = None
    transport = None
    try:
        # TCP connect
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(SSH_AUTH_TIMEOUT)
        sock.connect((host, port))

        # SSH handshake
        transport = paramiko.Transport(sock)
        transport.set_keepalive(5)
        transport.start_client(timeout=SSH_AUTH_TIMEOUT)

        # Authenticate
        try:
            transport.auth_password(username, password)
        except paramiko.AuthenticationException:
            try:
                transport.close()
            except Exception:
                pass
            return None
        except Exception as exc:
            if verbose:
                eprint(f"[ssh] auth exception on {host}:{port} for {username}: {exc}")
            try:
                transport.close()
            except Exception:
                pass
            return None

        # Post-auth: open a session and try to read any server output
        output = ""
        try:
            chan = transport.open_session(timeout=SSH_AUTH_TIMEOUT)
            try:
                chan.get_pty()
            except Exception:
                pass
            # Prefer an interactive shell; some lab servers print on shell start
            try:
                chan.invoke_shell()
            except Exception:
                # Fallback: run a tiny harmless command to flush output
                try:
                    chan.exec_command("echo")
                except Exception:
                    pass

            chan.settimeout(SSH_CHANNEL_READ_TIMEOUT)
            chan.set_combine_stderr(True)

            chunks = []
            try:
                while True:
                    data = chan.recv(4096)
                    if not data:
                        break
                    chunks.append(data)
                    if sum(len(c) for c in chunks) > 65536:  # cap read
                        break
            except Exception:
                pass
            finally:
                try:
                    chan.close()
                except Exception:
                    pass

            if chunks:
                output = b"".join(chunks).decode("utf-8", errors="ignore").strip()
        except Exception:
            output = ""

        # Always close transport
        try:
            transport.close()
        except Exception:
            pass

        # Only accept non-empty, non-banner output
        if not output:
            return None
        low = output.lower()
        if low.startswith("ssh-2.0") or "paramiko" in low:
            return None  # filter protocol banners like "SSH-2.0-paramiko_..."
        return output

    except Exception as exc:
        if verbose:
            eprint(f"[ssh] connection/auth error {host}:{port} {username}: {exc}")
        try:
            if transport:
                transport.close()
        except Exception:
            pass
        try:
            if sock:
                sock.close()
        except Exception:
            pass
        return None



# -------------- Probe single port --------------
def probe_port(host: str, port: int, credentials: dict[str, str], verbose: bool = False) -> None:
    """
    Try credentials for HTTP and SSH on the given port.
    On success print a single line to stdout and stop probing that port.
    """

    # HTTP first â€” if it succeeds, stop probing this port.
    for user, pwd in credentials.items():
        try:
            http_out = try_http_basic(host, port, user, pwd, verbose=verbose)
        except Exception:
            http_out = None
        if http_out is not None:
            out = sanitize_output(http_out)
            print(f"http://{user}:{pwd}@{host}:{port} {out}")
            return  # stop, don't try SSH on this port

    # SSH only if HTTP did not succeed
    if paramiko is None:
        return
    for user, pwd in credentials.items():
        try:
            ssh_out = try_ssh_password(host, port, user, pwd, verbose=verbose)
        except Exception:
            ssh_out = None
        if ssh_out:
            out = sanitize_output(ssh_out)
            if out:  # require non-empty captured output
                print(f"ssh://{user}:{pwd}@{host}:{port} {out}")
                return


# -------------- Main --------------
def main() -> None:
    parser = argparse.ArgumentParser(description="Local vulnerability scanner (HTTP basic + SSH password) for localhost")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose diagnostics to stderr")
    args = parser.parse_args()
    verbose = bool(args.verbose)

    open_ports: list[int] = []

    # Try nmap scan first (only if python-nmap is present)
    if nmap is not None:
        try:
            if verbose:
                eprint("Using python-nmap to discover open ports...")
            open_ports = nmap_scan_open_ports(HOST, PORT_LIMIT, verbose=verbose)
        except Exception as exc:
            if verbose:
                eprint(f"nmap scan failed: {exc}; falling back to socket scan")
            try:
                open_ports = socket_scan_open_ports(HOST, PORT_LIMIT)
            except Exception:
                open_ports = []
    else:
        if verbose:
            eprint("python-nmap not available; using socket-based scan")
        try:
            open_ports = socket_scan_open_ports(HOST, PORT_LIMIT)
        except Exception:
            open_ports = []

    if verbose:
        eprint(f"Open ports under {PORT_LIMIT}: {open_ports}")

    # Probe each open port (ignore >= PORT_LIMIT)
    for port in sorted(set(open_ports)):
        try:
            if port >= PORT_LIMIT:
                continue
            if verbose:
                eprint(f"Probing port {port}...")
            probe_port(HOST, port, CREDENTIALS, verbose=verbose)
        except Exception:
            # never allowed to print traceback; swallow and continue
            continue


if __name__ == "__main__":
    try:
        main()
    except Exception:
        # top-level safety: do not print traceback or errors to stdout/stderr
        # but if verbose we can note an unexpected top-level failure to stderr
        # (We purposely swallow to meet the "print nothing else" requirement.)
        pass