#!/usr/bin/env python3
"""
vulnerability_scanner.py

Scan localhost (127.0.0.1) for open TCP ports < 9000, then attempt:
 - HTTP Basic Auth using credentials dict
 - SSH password auth using paramiko (if available)

On successful authentication print exactly:
  http://user:pass@127.0.0.1:8080 <server-output>
  ssh://user:pass@127.0.0.1:2222 <server-output>

No other stdout output. Use -v/--verbose to send diagnostics to stderr only.
"""

from __future__ import annotations
import argparse
import socket
import sys
import re
import logging
logging.getLogger("paramiko").setLevel(logging.CRITICAL)
logging.getLogger("paramiko.transport").setLevel(logging.CRITICAL)


# Optional modules
try:
    import nmap  # python-nmap
except Exception:
    nmap = None

try:
    import requests
    from requests.auth import HTTPBasicAuth
except Exception:
    requests = None

try:
    import paramiko
except Exception:
    paramiko = None

# Silence paramiko internal logging/noisy messages
logging.getLogger("paramiko").setLevel(logging.CRITICAL)
logging.getLogger("paramiko.transport").setLevel(logging.CRITICAL)

# -------------- Configuration --------------
HOST = "127.0.0.1"
PORT_LIMIT = 9000  # ignore ports >= 9000
CREDENTIALS = {
    "admin": "admin",
    "root": "abc123",
    "skroob": "12345",
}

SOCKET_SCAN_TIMEOUT = 0.2  # seconds per port on fallback scan
HTTP_TIMEOUT = 3.0
SSH_AUTH_TIMEOUT = 5.0
SSH_CHANNEL_READ_TIMEOUT = 1.0
MAX_OUTPUT_CHARS = 2000  # truncate long outputs

# Regex to collapse whitespace
_whitespace_re = re.compile(r"\s+")


# -------------- Utilities --------------
def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def sanitize_output(s: str | None, max_len: int = MAX_OUTPUT_CHARS) -> str:
    """Collapse whitespace to single spaces, trim, and truncate to a single-line string."""
    if s is None:
        return ""
    s2 = _whitespace_re.sub(" ", s.strip())
    if len(s2) > max_len:
        s2 = s2[:max_len]
    return s2


# -------------- Port discovery --------------
def nmap_scan_open_ports(host: str = HOST, max_port: int = PORT_LIMIT, verbose: bool = False) -> list[int]:
    """
    Use python-nmap to scan TCP ports 1..max_port-1.
    Requires the nmap binary to be available; python-nmap will raise if it isn't.
    """
    if nmap is None:
        raise RuntimeError("python-nmap not installed")
    scanner = nmap.PortScanner()
    port_range = f"1-{max_port - 1}"
    try:
        # -sT TCP connect scan; -Pn treat host as up
        scanner.scan(hosts=host, ports=port_range, arguments="-sT -Pn")
    except Exception as exc:
        raise RuntimeError(f"nmap scan error: {exc}") from exc

    open_ports: list[int] = []
    try:
        host_info = scanner[host]
        tcp_info = host_info.get("tcp", {}) or {}
        for p_str, info in tcp_info.items():
            if str(info.get("state", "")).lower() == "open":
                open_ports.append(int(p_str))
    except Exception:
        # Unexpected structure; return empty
        return []
    return sorted(open_ports)


def socket_scan_open_ports(host: str = HOST, max_port: int = PORT_LIMIT) -> list[int]:
    """Fallback: simple socket connect scan for ports 1..max_port-1."""
    open_ports = []
    for port in range(1, max_port):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(SOCKET_SCAN_TIMEOUT)
        try:
            if s.connect_ex((host, port)) == 0:
                open_ports.append(port)
        except Exception:
            # ignore
            pass
        finally:
            try:
                s.close()
            except Exception:
                pass
    return open_ports


# -------------- HTTP probing --------------
def try_http_basic(host: str, port: int, username: str, password: str, verbose: bool = False) -> str | None:
    """
    Attempt HTTP Basic Auth to http://host:port/ .
    Return response body (possibly empty string) on success, or None on failure.
    We treat a successful connection with a non-401 response as success (so 2xx/3xx/4xx non-401)
    to be tolerant of brittle stubs. Adjust as needed.
    """
    if requests is None:
        if verbose:
            eprint("[http] requests not available; skipping HTTP attempts.")
        return None
    url = f"http://{host}:{port}/"
    try:
        r = requests.get(url, auth=HTTPBasicAuth(username, password), timeout=HTTP_TIMEOUT, allow_redirects=False)
        # Treat 401 as an auth failure; everything else we return the body (could be empty)
        if r.status_code == 401:
            return None
        # Return the response body (may be empty). Use text if available.
        text = r.text if r.text is not None else (r.content.decode(errors="ignore") if r.content else "")
        return text
    except Exception as exc:
        if verbose:
            eprint(f"[http] {host}:{port} {username}:{password} -> exception: {exc}")
        return None


# -------------- SSH probing --------------
def try_ssh_password(host: str, port: int, username: str, password: str, verbose: bool = False) -> str | None:
    """
    Attempt SSH password authentication via paramiko.
    Return captured output (banner or post-auth output, possibly empty string) on success, or None on failure.
    Does not read from the socket before constructing the Transport to avoid breaking Paramiko's banner reading.
    """
    if paramiko is None:
        if verbose:
            eprint("[ssh] paramiko not available; skipping SSH attempts.")
        return None

    sock = None
    transport = None
    try:
        # connect TCP (do NOT pre-read)
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(SSH_AUTH_TIMEOUT)
        sock.connect((host, port))

        # create transport and perform banner/client handshake
        transport = paramiko.Transport(sock)
        transport.set_keepalive(5)
        transport.start_client(timeout=SSH_AUTH_TIMEOUT)

        # lightweight banner info if present
        banner = getattr(transport, "remote_version", "") or ""
        if isinstance(banner, bytes):
            try:
                banner = banner.decode(errors="ignore")
            except Exception:
                banner = str(banner)
        banner = banner.strip()

        # AUTHENTICATE (no 'timeout' kw here)
        try:
            transport.auth_password(username, password)
        except paramiko.AuthenticationException:
            try:
                transport.close()
            except Exception:
                pass
            return None
        except Exception as exc:
            if verbose:
                eprint(f"[ssh] auth exception on {host}:{port} for {username}: {exc}")
            try:
                transport.close()
            except Exception:
                pass
            return None

        # If auth succeeded, try to read any server output
        output = ""
        try:
            chan = transport.open_session(timeout=SSH_AUTH_TIMEOUT)
            try:
                chan.get_pty()
            except Exception:
                pass
            try:
                chan.invoke_shell()
            except Exception:
                try:
                    chan.exec_command("echo")
                except Exception:
                    pass

            chan.settimeout(SSH_CHANNEL_READ_TIMEOUT)
            chunks = []
            try:
                while True:
                    data = chan.recv(4096)
                    if not data:
                        break
                    chunks.append(data)
                    if sum(len(c) for c in chunks) > 65536:
                        break
            except Exception:
                pass
            try:
                chan.close()
            except Exception:
                pass

            if chunks:
                output = b"".join(chunks).decode(errors="ignore").strip()
        except Exception:
            output = ""

        try:
            transport.close()
        except Exception:
            pass

        # prefer post-auth output; otherwise banner (could be empty)
        return output if output else banner

    except Exception as exc:
        if verbose:
            eprint(f"[ssh] connection/auth error {host}:{port} {username}: {exc}")
        try:
            if transport:
                transport.close()
        except Exception:
            pass
        try:
            if sock:
                sock.close()
        except Exception:
            pass
        return None



# -------------- Probe single port --------------
def probe_port(host: str, port: int, credentials: dict[str, str], verbose: bool = False) -> None:
    """
    Try credentials for HTTP and SSH on the given port.
    On success print a single line (to stdout) per success in the specified format.
    """
    # HTTP
    for user, pwd in credentials.items():
        try:
            http_out = try_http_basic(host, port, user, pwd, verbose=verbose)
            if http_out is not None:
                out = sanitize_output(http_out)
                # Print exactly one line per successful HTTP auth
                print(f"http://{user}:{pwd}@{host}:{port} {out}")
                # stop trying other HTTP creds for this port
                break
        except Exception:
            # swallow any problems
            continue

    # SSH
    for user, pwd in credentials.items():
        try:
            ssh_out = try_ssh_password(host, port, user, pwd, verbose=verbose)
            if ssh_out is not None:
                out = sanitize_output(ssh_out)
                print(f"ssh://{user}:{pwd}@{host}:{port} {out}")
                break
        except Exception:
            continue


# -------------- Main --------------
def main() -> None:
    parser = argparse.ArgumentParser(description="Local vulnerability scanner (HTTP basic + SSH password) for localhost")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose diagnostics to stderr")
    args = parser.parse_args()
    verbose = bool(args.verbose)

    open_ports: list[int] = []

    # Try nmap scan first (only if python-nmap is present)
    if nmap is not None:
        try:
            if verbose:
                eprint("Using python-nmap to discover open ports...")
            open_ports = nmap_scan_open_ports(HOST, PORT_LIMIT, verbose=verbose)
        except Exception as exc:
            if verbose:
                eprint(f"nmap scan failed: {exc}; falling back to socket scan")
            try:
                open_ports = socket_scan_open_ports(HOST, PORT_LIMIT)
            except Exception:
                open_ports = []
    else:
        if verbose:
            eprint("python-nmap not available; using socket-based scan")
        try:
            open_ports = socket_scan_open_ports(HOST, PORT_LIMIT)
        except Exception:
            open_ports = []

    if verbose:
        eprint(f"Open ports under {PORT_LIMIT}: {open_ports}")

    # Probe each open port (ignore >= PORT_LIMIT)
    for port in sorted(set(open_ports)):
        try:
            if port >= PORT_LIMIT:
                continue
            if verbose:
                eprint(f"Probing port {port}...")
            probe_port(HOST, port, CREDENTIALS, verbose=verbose)
        except Exception:
            # never allowed to print traceback; swallow and continue
            continue


if __name__ == "__main__":
    try:
        main()
    except Exception:
        # top-level safety: do not print traceback or errors to stdout/stderr
        # but if verbose we can note an unexpected top-level failure to stderr
        # (We purposely swallow to meet the "print nothing else" requirement.)
        pass
